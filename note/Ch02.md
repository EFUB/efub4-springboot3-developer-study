# 스프링과 스프링부트

- 엔터프라이즈 애플리케이션 : 대규모의 복잡한 데이터를 관리하는 애플리케이션.
    - 많은 사용자의 요청을 동시에 처리해야 함. → 서버의 안정성, 보안이 매우 중요함. → 이것을 고려하며 비즈니스 로직까지 개발하기 매우 어려움.
- 엔터프라이즈 애플리케이션을 위한 개발 환경을 제공하여 기능 개발에만 집중할 수 있다면 매우 편리할 것임

  → 이렇게 등장한 것이 스프링부트.


### 스프링부트

- 스프링 프레임워크를 더 쉽고 빠르게 이용할 수 있도록 만들어주는 도구.
    - 빠르게 스프링 프로젝트 설정 가능.
    - 스타터를 사용해 간편하게 의존성 관리 가능.
- 개발자가 비즈니스 로직 개발에만 집중할 수 있도록 만들어줌.
- 스프링 부트의 특징.
    1. 톰캣 등 웹 애플리케이션 서버가 내장되어 있어서 따로 설치 없이 독립적 실행 가능.
    2. 빌드 구성을 단순화하는 스프링 부트 스타터 제공.
    3. XML 설정을 하지 않고 자바 코드로 모두 작성 가능.
    4. JAR 을 이용하여 자바 옵션만으로 배포 가능.
    5. 애플리케이션의 모니터링 및 관리 도구인 스프링 액츄에이터 제공.
- 스프링과 스프링 부트 특징 비교
    - 스프링
        - 목적 : 엔터프라이즈 애플리케이션 개발을 더 쉽게 만들기
        - 설정 파일 : 개발자가 수동으로 구성.
        - XML : 일부 파일은 XML로 직접 생성하고 관리.
        - 인메모리 데이터베이스 지원 : 지원 안 함.
        - 서버 : 프로젝트를 띄우는 서버를 별도로 수동 설정.
    - 스프링 부트
        - 목적 : 스프링의 개발을 더 빠르고 쉽게 하기
        - 설정 파일 : 자동 구성.
        - XML : 사용하지 않음.
        - 인메모리 데이터베이스 지원 : 인메모리 데이터베이스 자동 설정 지원.
        - 서버 : 내장형 서버를 제공해 별도의 설정이 필요 없음.

---

# 스프링 콘셉트 공부

### 제어의 역전과 의존성 주입

`IoC` : 제어의 역전. `Inversion of Control`

**객체의 생성과 관리를 개발자가 하는 것이 아니라 프레임워크가 대신함.**

- 외부에서 관리하는 객체를 가져와 사용함.

    ```java
    // 직접 객체 생성
    public class A{
    	b = new B();
    }
    
    // IoC. 스프링 컨테이너가 객체를 관리하는 방식
    public class A{
    	private B b; // 직접 객체를 생성하지 않고, 어디선가 받아온 객체를 b에 할당.
    }
    ```


`DI` : 의존성 주입. `Dependency Injection`

**외부에서 객체를 주입받아 사용함.**

- 어떤 클래스가 다른 클래스에 의존함.
- 예를 들어, `@Autowired` 는 스프링 컨테이너에 있는 **빈**이라는 것을 주입하는 역할을 함.

    ```java
    public class A{
    	//A에서 B를 주입받음.
    	@Autowired
    	B b;
    }
    ```

- **스프링에서는 객체를 쓰고 싶을 때 직접 생성하는 것이 아니라 스프링 컨테이너에서 객체를 주입받아 사용함**.

### 스프링 컨테이너

- 빈을 생성하고 관리함.
- 빈의 생성 ~ 소멸까지의 생명주기를 스프링 컨테이너가 관리함.
- DI를 지원.

### 빈

- 스프링 컨테이너가 생성하고 관리하는 객체.
- 빈을 스프링 컨테이너에 등록하기 위한 방법은 다양함.
    - 애너테이션 추가.
    - XML 파일 설정.
    - 예를 들어,

        ```java
        @Component // 클래스 MyBean 빈으로 등록함.
        public class MyBean{
        }
        ```


### 관점 지향 프로그래밍

**프로그래밍을 할 때 핵심 관점과 부가 관점으로 나누어서 개발함.**

- `AOP` : `Aspect Oriented Programming`
- 프로그래밍에 대한 관심을 핵심 관점, 부가 관점으로 나누어서 관심 기준으로 모듈화함.
- 부가 관점 코드를 핵심 관점 코드에서 분리함.
- 프로그램의 변경과 확장에 유연하게 대응 가능함.

### 이식 가능한 서비스 추상화

**어느 기술을 사용하던 일관된 방식으로 처리하도록 함.**

- `PSA` : `Portable Service Abstraction`
- 스프링에서 제공하는 다양한 기술들을 추상화해 개발자가 쉽게 사용하는 인터페이스를 개발함.
- 예를 들어, 스프링에서는 JPA, JDBC 등 데이터베이스에 접근하기 위한 다양한 기술들이 일관도니 방식으로 데이터베이스에 접근하도록 인터페이스를 제공함.

---

# 스프링부트 3 둘러보기

- http://localhost:8080/test
    - [localhost](http://localhost) 의 ip : 127.0.0.1
        - 컴퓨터 네트워크에서 사용하는 루프백 호스트명.
        - 현재 사용중인 컴퓨터
    - 8080 : 스프링 부트의 포트 번호.
    - /test : 애너테이션으로 메서드와 매핑할 때 스프링 부트에서 설정한 **경로.**

### 스프링 부트 스타터

- 의존성이 모여있는 구룹.
- 명명규칙 : `spring-boot-starter-{작업유형}`

### 자동 구성

- 스프링 부트에서는 애플리케이션이 최소한의 설정으로 실행되게 여러 부분을 자동으로 구성함.
- 스프링 부트는 서버를 시작할 때 구성 파일을 읽어와 설정함 = 자동 설정

  →자동 설정은 META-INF애 있는 spring.factories 파일에 있음.


### 스프링부트3과 자바 버전

- 기존의 스프링부트2는 자바8버전 이상.
- 스프링부트3은 자바17 이상.
- 자바17 의 주요 변화
    1. 텍스트 블록 : 이전에는 여러 줄의 텍스트를 작성하기 위해서는 \n을 추가해야 했지만 이제는 `"""` 로 감싼 텍스트를 사용하면 됨.
    2. formattes() 메서드
    3. 레코드 : 데이터 전달을 목적으로 하는 객체를 더 빠르고 간편하게 만들기 위한 기능.
        - 레코드는 상속을 할 수 없음.
        - 파라미터에 정의한 필드는 `private final` 로 정의됨.
        - `getter()` 을 자동 생성함.

        ```java
        record Item(String name, int price){
        // 파라미터가 private final 로 정의됨.
        }
        Item juice = new Item("juice",3000);
        juice.price(); // 3000
        ```

    4. 패턴 매칭 : 바로 형변환 가능.

        ```java
        // 11버전
        if(o instanceof Integer){
        	Integer i = (Integer)o;
        	...
        }
        
        // 17버전
        if(o instanceof Integer i){
        	...
        }
        ```

    5. 자료형에 맞는 case 처리
    6. Servlet, JPA의 네임 스페이스가 Jakarta로 대체
        - `javax.*` → `Jakarta.*`
    7. GraalVM기반의 스프링 네이티브 공식 지원.
        - 기존에 사용하던 자바 가상 머신에 비해 훨씬 빠르게 시작됨.
        - 더 적은 메모리 공간을 차지함.
        - 가동 시간이 짧아지고 메모리를 더 적게 소모.

---

# 스프링부트3 코드 이해하기

### @SpringBootApplication

- 스프링 관련 기본 설정을 해줌.
    - `SpringApplication.run()` : 애플리케이션을 실행함.
        - 첫 인수 : 애플리케이션의 메인 클래스로 사용할 클래스.
        - 두 번째 인수 : 커맨드 라인의 인수들을 전달.
- `**@SpringBootConfiguration**` : 스프링부트 관련 설정을 아는 애너테이션.
- `**@ComponentScan**` : **사용자가 등록한 빈을 읽고 등록하는 애너테이션.**
    - `@Component` 라는 애너테이션을 가진 클래스들을 찾아 빈으로 등록함.
        - 모든 빈에 이 애너테이션을 사용하는 것은 아님.
        - `@Configuration` : 설정 파일 등록
        - `@Repository` : ORM 매핑
        - `@Controller` , `@RestController` : 라우터
        - `@Service` : 비즈니스 로직.

      → 이 애노테이션들 안에는 이미 `@Component` 애노테이션을 가지고 있음. 따라서 빈으로 등록됨.

- `**@EnableAutoConfiguration**` : 스프링 부트에서 자동 구성을 활성화하는 애너테이션.
    - **자동 설정으로 등록되는 빈을 읽고 등록함.**
    - 스프링부트 서버가 실행될 때 스프링 부트의 메타 파일을 읽고 정의된 설정들을 자동으로 구성하는 역할을 수행함.
    - 이전에 ‘자동 구성’ 파트에서 살펴본 spring.factories 파일의 클래스들이 이 애너테이션을 사용할 때 자동 설정됨.

### 테스트 컨트롤러

- `@Restcontroller` : 라우터 역할을 하는 애너테이션.
    - 라우터 : HTTP 요청과 메서드를 연결하는 장치.
    - 이 애노테이션이 @ComponentScan 으로 빈으로 등록되는 이유는 @Controller 애너테이션이 @Component 애너테이션을 가지고 있기 때문.