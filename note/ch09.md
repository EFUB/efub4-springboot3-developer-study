# JWT로 로그인/로그아웃 구현하기

## 9.1 사전 지식: 토큰 기반 인증

**토큰 기반 인증**

- 세션 기반 인증
   - 스프링 시큐리티에서는 기본적으로 세션 기반 인증을 제공
   - 사용자마다 사용자의 정보를 담은 세션을 생성하고 저장해서 인증

- 토큰 기반 인증
   - 토큰: 서버에서 클라이언트를 구분하기 위한 유일한 값
   - 서버가 토큰을 생성해서 클라이언트에게 제공하면, 클라이언트는 이 토큰을 갖고 있다가 여러 요청을 이 토큰과 함께 신청 -> 서버는 토큰으로 유효한 사용자인지 검증

   <br>

- 토큰을 전달하고 인증받는 과정
   1. 클라이언트가 아이디와 비밀번호를 서버에게 전달하면서 인증을 요청
   2. 서버는 아이디와 비밀번호를 확인해 유효한 사용자인지 검증, 유효한 사용자면 토큰을 생성해서 응답
   3. 클라이언트는 서버에서 준 토큰을 저장
   4. 이후 인증이 필요한 API를 사용할 때 토큰을 함께 전송
   5. 서버는 토큰이 유효한지 검증
   6. 토큰이 유효하다면 클라이언트의 요청 처리

   <br>

- 토큰 기반 인증의 특징
   - 무상태성
      - 토큰이 서버가 아닌 클라이언트에 있으므로 서버에 저장할 필요가 없음 
      - 서버 입장에서는 클라이언트의 인증 정보를 저장하거나 유지하지 않아도 되기 때문에 완전한 무상태로 효율적인 검증 가능
   - 확장성
      - 무상태성에 의해 서버를 확장할 때 상태 관리를 신경 쓸 필요 없음 -> 서버 확장 용이
      - 세션 인증 기반은 각각 API에서 인증을 해야 되는 것과 달리, 토큰 기반 인증에서는 토큰을 가지는 주체는 클라이언트이기 때문에 가지고 있는 하나의 토큰으로 분리된 서버에게도 요청을 보낼 수 있음
      - 페이스북 로그인, 구글 로그인 같이 토큰 기반 인증을 사용하는 다른 시스템에 접근해 로그인 방식을 확장, 권한 공유 가능
   - 무결성
      - HMAC (hash-based message authentication) 기법
      - 토큰 무결성 보장: 토큰을 발급한 이후에는 토큰 정보를 변경할 수 없음
      - 토큰의 한 글자라도 변경하면 서버에서는 유효하지 않은 토큰이라고 판단


**JWT**

- JWT를 이용해 인증을 하려면 HTTP 요청 헤더 중에 Authorization 키값에 Bearer+JWT 토큰값을 넣어 보내야 함


**JWT 구조**
- {헤더} . {내용} . {서명}
   - 헤더: 토큰의 타입과 해싱 알고리즘을 지정하는 정보
   - 내용: 토큰과 관련된 정보
      - 클레임: 내용의 한 덩어리, 키값의 한 쌍
         - 등록된 클레임 : 토큰에 대한 정보를 담는 데 사용
         - 공개 클레임 : 공개되어도 상관없는 클레임. 충돌을 방지할 수 있는 이름. 보통 URL로 이름 지음
         - 비공개 클레임 : 공개되면 안 되는 클레임
   - 서명: 토큰이 조작되었거나 변경되지 않았음을 확인하는 용도

<br>

**토큰의 유효기간**
- 리프레시 토큰
   - 사용자를 인증하기 우한 용도가 아닌 액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급하기 위해 사용
   - 액세스 토큰의 유효기간을 짧게 설정하고, 리프레시 토큰의 유효기간을 길게 설정하면 공격자가 액세스 토큰을 탈취해도 몇 분 뒤에는 사용할 수 없는 토큰이 되므로 안전

- 리프레시 토큰 과정
   1. 클라이언트가 서버에게 인증을 요청
   2. 서버는 클라이언트에서 전달한 정보를 바탕으로 인증 정보가 유효한지 확인한 뒤, 액세스 토큰과 리프레시 토큰을 만들어 클라이언트에게 전달, 클라이언트는 토큰을 저장
   3. 서버에서 생성한 리프레시 토큰은 DB에도 저장
   4. 인증을 필요로 하는 API를 호출할 때 클라이언트에 저장된 액세스 토큰과 함께 API를 요청
   5. 서버는 전달받은 액세스 토큰이 유효한지 검사한 뒤에 유효하다면 클라리언트에서 요청한 내용을 처리
   6. 액세스 토큰이 만료된 뒤 클라이언트에서 원하는 정보를 얻기 위해 서버에게 API요청
   7. 서버는 액세스 토큰이 유효한지 검사. 만료된 토큰이면 유효하지 않기 때문에 토큰이 만료되었다는 에러 전달
   8. 클라이언트는 저장해둔 리프레시 토큰과 함께 새로은 액세스 토큰을 발급하는 요청 전송
   9. 서버는 리프레시 토큰이 유효한지, DB에서 리프레시 토큰을 조회한 후 저장해둔 리프레시 토큰과 같은지 확인
   10. 유효한 리프레시 토큰이라면 새로운 액세스 토큰을 생성한 뒤 응답


## 9.2 JWT 서비스 구현하기

실제로 JWT를 생성하고, 검증하는 서비스를 구현

**의존성 추가하기**
- 자바에서 JWT를 사용하기 위한 라이브러리, XML 문서와 Java 객체 간 매핑 자동화하는 jax-api 추가

<br>

**토큰 제공자 추가하기**
- jwt를 사용하여 JWT를 생성하고 유효한 토큰인지 검증하는 역할의 클래스 추가
- application.yml
   - 이슈 발급자와 비밀키를 설정
- JwtProperties : 이슈 발급자와 비밀키 값을 변수로 접근하는 클래스
- TokenProvider : 토큰을 생성하고 올바른 토큰인지 유효성을 검사하고, 토큰에서 필요한 정보를 가져오는 클래스
   1. makeToken : 토큰 생성 메서드
      - 인자로 만료 시간, 유저 정보 받음
      - 헤더 : typ(타입)
      - 내용 : iss(발급자), iat(발급일시), exp(만료일시), sub(토큰제목)
      - 클레임 : 유저 ID 지정
   2. validToken : 토큰이 유효한지 검증하는 메서드
      - 프로퍼티즈 파일에 선언한 비밀값과 함께 토큰 복호화 진행
      - 복호화 과정에서 에러가 발생하면 false(유효하지 않은 토큰), 에러 발생하지 않으면 true 반환
   3. getAuthentication : 토큰을 받아 인증절보를 담은 객체를 반환하는 메서드
      - getClaims()를 호출하여 클레임 정보를 반환받아 인증 정보 생성
      - UsernamePasswordAuthenticationToken의 첫인자 User는 스프링 시큐리티에서 제공하는 객체인 User 클래스 임포트 해야함
   4. 토큰 기반으로 사용자 ID를 가져오는 메서드
      -  getClaims()를 호출하여 클레임 정보를 반환받고 클레임에서 id 키로 저장된 값을 가져와 반환
- TokenProviderTest
   1. generateToken() : 토큰 생성 메서드 테스트
      - given : 토큰 유저 정보를 추가하기 위한 테스트 유저 생성
      - when : 토큰 제공자의 generateToken() 메서드 토큰 생성
      - then : jjwt 라이브러리를 사용하여 토큰을 복호화. 토큰 만들 때 클레임으로 넣어둔 id값이 given절에서 만든 유저 ID와 동일한지 확인
   
   2. validToken_invalidToken() : 검증 실패를 테스트, validToken_validToken() : 검증 성공을 테스트
      - given : jjwt 라이브러리를 사용해 토큰 생성
      - when : 토큰 제공자의 validToken() 메서드를 호출해 유효한 토큰인지 검증, 결괏값 반환
      - then : false(true)임을 확인
   3. getAuthentication() : getAuthentication() 테스트
      - given :  jjwt 라이브러리를 사용해 토큰 생성
      - when : 토큰 제공자의 getAuthentication() 메서드 호출해 인증 객체 반환
      - then : 인증 객체의 유저 이름을 가져와 given절에서 설정한 subject값과 같은지 확인
   4. getUserId() : 유저id를 가져오는 메서드 테스트
      - given : jjwt 라이브러리를 사용해 토큰 생성
      - when : 토큰 제공자의 getUserId() 메서드 호출해 유저 ID 반환
      - then : 유저 ID가 given절에서 설정한 유저 ID값과 같은지 확인

<br>

**리프레시 토큰 도메인 구현하기**

리프레시 토큰을 데이터베이스에 저장하는 정보이므로 엔티티와 리포지터리를 추가
- RefreshToken
- RefreshTokenRepository

<br>

**토큰 필터 구현하기**
- 토큰 필터는 실제로 요청을 처리하기 위한 로직으로 전달되지 전후에 URL 패턴에 맞는 모든 요청을 처리하는 기능 제공
   - 요청이 오면 헤더값을 비교해 토큰이 있는지 확인하고 유효 토큰이라면 시큐리티 콘텍스트 홀더에 인증 정보를 저장
   - 시큐리티 콘텍스트: 인증객체가 저장되는 보관소
      - 이 클래스는 스레드 로컬에 저장되므로 코드 아무 곳에서나 참조할 수 있고, 다른 스레드와 공유하지 않으므로 독립적으로 사용 가능
      - 시큐리티 콘텍스트 홀더 : 시큐리티 컨텍스트 객체를 저장하는 객체
- TokenAuthenticationFilter
   - 요청헤더에서 키가 ‘Authorization’인 필드의 값을 가져온 다음 토큰의 접두사 Bearer를 제외한 값을 얻음
   - 값이 null이거나 Bearer로 시작하지 않으면 null 반환
   - 가져온 토큰이 유효한지 확인, 유효하다면 인증 정보를 관리하는 시큐리티 컨텍스트에 인증 정보를 설정
   - 코드가 실행되며 인증 정보가 설정된 이후에 컨텍스트 홀더에서 getAuthentication() 메서드를 사용해 인증 정보를 가져오면 유저 객체 반환

## 9.3 토큰 API 구현하기

리프레시 토큰을 전달받아 토큰 제공자를 사용해 새로운 액세스 토큰을 만드는 토큰 서비스 클래스를 생성

**토큰 서비스 추가하기**
- RefreshTokenService
   - findByRefreshToken(): 전달받은 리프레시 토큰으로 리프레시 토큰 객체를 검색해서 전달
- TokenService
   - createNewAccessToken(): 전달받은 리프레시 토큰으로 토큰 유효성검사를 진행하고, 유효한 토큰일 때 리프레시 토큰으로 사용자 ID를 찾아서 토큰 제공자의 generatetToken()으로 새로운 액세스 토큰 생성

**컨트롤러 추가하기**

실제로 토큰을 발급받는 API생성
- CreateAccessTokenRequest, CreateAccessTokenResponse
- TokenApiController
   - /api/token POST 요청이 오면 새로운 액세스 토튼 생성
- TokenApiControllerTest
   - given : 테스트 유저 생성, jjwt 라이브러리로 리프레시 토큰을 만들어 데이터베이스에 저장
   - when : 토큰 추가 api에 요청 보냄
   - then : 응답코드가 201 created인지 확인하고 액세스 토큰이 비어있지 않은지 확인

