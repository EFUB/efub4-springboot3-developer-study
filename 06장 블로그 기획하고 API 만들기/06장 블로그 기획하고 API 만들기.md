# 06장 블로그 기획하고 API 만들기

## 6.1 사전 지식: API와 REST API

- 6.1.1 식당으로 알아보는 API
    - 예) 웹 사이트의 주소를 입력해서 ‘구글 메인 화면을 보여줘’라는 요청을 보냄 → API가 요청을 서버에게 가져다 줌 → 서버는 API가 준 요청을 처리해 결과물을 만듦 → 결과물을 다시 API로 전달 → API는 최종 결과물을 브라우저에 보냄
    - API
        - 클라이언트의 요청을 서버에 잘 전달하고, 서버의 결과물을 클라이언트에게 잘 돌려주는 역할
- 6.1.2 웹의 장점을 최대한 활용하는 REST API
    - REST API
        - Representational State Transfer
        - 자원을 이름으로 구분해 자원의 상태를 주고받는 API 방식(명확하고 이해하기 쉬운 API)
        - URL 설계 방식을 의미함
        - 특징
            - 서버/클라이언트 구조
            - 무상태
            - 캐시 처리 가능
            - 계층화
            - 인터페이스 일관성
        - 장점
            - **주소와 메서드만 보고 요청의 내용을 파악할 수 있음**
            - URL만 보고도 무슨 행동을 하는 API인지 명확하게 알 수 있음
            - 상태가 없다 → 클라이언트와 서버의 역할이 명확하게 분리됨
            - HTTP 표준을 사용하는 모든 플랫폼에서 사용할 수 있음
        - 단점
            - HTTP 메서드, 즉 GET, POST와 같은 방식의 개수에 제한이 있고 설계를 하기 위해 공식적으로 제공되는 표준 규약이 없음
        - 사용 방법
            - **규칙 1. URL에는 동사를 쓰지 말고, 자원을 표시해야 한다**
                - 자원 : 가져오는 데이터
                - 예) 학생 중 id가 1인 학생의 정보를 가져오는 URL : /students/1
            - 규칙 2. 동사는 HTTP 메서드로
                - HTTP 메서드
                    - 서버에 요청을 하는 방법을 나눈 것
                    - 주로 POST(create), GET(read), PUT(update), DELETE(delete)를 사용함
                    - 위 4가지 역할을 묶어 CRUD(크루드)라고 부름
                - 예) 블로그에 글을 쓰는 설계
                    - id가 1인 블로그 글을 **조회**하는 API : **GET** /articles/1
                    - 블로그 글을 **추가**하는 API : **POST** /articles/1
                    - 블로그 글을 **수정**하는 API : **PUT** /articles/1
                    - 블로그 글을 **삭제**하는 API : **DELETE** /articles/1

## 6.2 블로그 개발을 위한 엔티티 구성하기

- 6.2.1 프로젝트 준비하기
- 6.2.2 엔티티 구성하기
    - 엔티티와 매핑되는 테이블 구조
        
        
        | 칼럼명 | 자료형 | null 허용 | 키 | 설명 |
        | --- | --- | --- | --- | --- |
        | id | BIGINT | N | 기본키 | 일련번호 기본키 |
        | title | VARCHAR(255) | N |  | 게시물의 제목 |
        | content | VARCHAR(255) | N |  | 내용 |
    - @Builder
        - 롬복에서 지원하는 애너테이션
        - 생성자 위에 입력하면 빌더 형식으로 객체 생성 가능
        - 객체를 유연하고 직관적으로 생성할 수 있어 개발자들이 애용하는 디자인 패턴
        - 빌더 패턴 예
            
            ```java
            // 빌더 패턴을 사용하지 않았을 때
            new Article("abc", "def")
            
            // 빌더 패턴을 사용했을 때
            Article.builder()
            	.title("abc")
            	.content("def")
            	.build();
            ```
            
    - 롬복을 사용하여 코드를 간결화하기
        - @NoArgsConstructor를 사용해 접근 제어자가 protected인 기본 생성자를 별도의 코드 없이 생성
        - @Getter로 클래스 필드에 별도 코드 없이 생성자 메서드 만듦
        
        **⇒ 롬복 에너테이션을 사용해 코드를 반복 입력 필요 X → 가독성 향상**
        
    - 6.2.3 리포지터리 만들기

## 6.3 블로그 글 작성을 위한 API 구현하기

- 구현 과정
    - 서비스 클래스에서 메서드 구현, 컨트롤러에서 사용할 메서드 구현, API로 실제 테스트
    - 6.3.1 서비스 메서드 코드 작성하기
        - 블로그에 글을 추가하는 코드 작성
        - AddArticleRequest 객체 생성, BlogService 클래스 생성, 블로그 글 추가 메서드인 save() 구현
        - DTO
            - 계층끼리 데이터를 교환하기 위해 사용하는 객체
            - 별도의 비즈니스 로직 포함하지 않음
        - toEntity() : 빌더 패턴을 사용해 DTO를 엔티티로 만들어주는 메서드로 추후 블로그 글을 추가할 때 저장할 엔티티로 변환하는 용도로 사용함
    - 6.3.2 컨트롤러 메서드 코드 작성하기
        - 컨트롤러 메서드에는 URL 매핑 애너테이션 @GetMapping, @PostMapping, @PutMapping, @DeleteMaaping 등에 사용할 수 있음
        - /api/articles에 POST 요청이 오면 @PostMapping을 이용해 요청을 매핑 → 블로그 글을 생성하는 BlogService save() 호출 → 생성된 블로그 글을 반환하는 addArticle() 작성
    - 6.3.3 API 실행 테스트하기
        - H2 콘솔 활성화
    - 6.3.4 반복 작업을 줄여 줄 테스트 코드 작성하기
        - 직렬화 : 자바 객체를 JSON 데이터로 변환함
        - 역직렬화 : JSON 데이터를 자바에서 사용하기 위해 자바 객체로 변환함
        - writeValueAsString() 메서드를 사용하여 객체를 JSON으로 직렬화
        - MockMvc를 사용해 HTTP 메서드, URL, 요청 본문, 요청 타입 등 설정
        - 설정한 내용 바탕으로 테스트 요청 보냄
        - contentType() 메서드 : 요청을 보낼 때 다양한 타입 중 하나를 골라 요청 보냄
        - assertThat()으로 블로그 글의 개수가 1인지 확인

## 6.4 블로그 글 목록 조회를 위한 API 구현하기

- 6.4.1 서비스 메서드 코드 작성하기
    - BlogService.java에 데이터베이스에 저장되어 있는 글을 모두 가져오는 findAll() 메서드 추가
- 6.4.2 컨트롤러 메서드 코드 작성하기
    - /api/articles GET 요청이 오면 글 목록을 조회할 findAllArticles() 메서드 작성
    - 전체 글 목록을 조회하고 응답하는 역할을 함
- 6.4.3 실행 테스트하기
    - data.sql 파일 생성 후 포스트맨에서 결과 실행
- 6.4.4 테스트 코드 작성하기
    - given : 블로그 글 저장
    - when : 목록 조회 API 호출
    - then : 응답 코드가 200 OK이고, 반환받은 값 중에 0번째 요소의 content와 title이 저장된 값과 같은지 확인

## 6.5 블로그 글 조회 API 구현하기

- 6.5.1 서비스 메서드 코드 작성하기
    - BlogService.java에 블로그 글 하나를 조회하는 메서드인 findById() 메서드 추가
        - 데이터베이스에 저장되어 있는 글의 ID를 이용해 글 조회
- 6.5.2 컨트롤러 메서드 코드 작성하기
    - /api/articles/{id} GET 요청이 오면 블로그 글을 조회하기 위해 매핑할 findArticle() 메서드 작성
    - @PathVariable : URL에서 값 가져오는 애너테이션
- 6.5.3 테스트 코드 작성하기
    - given : 블로그 글 저장
    - when : 저장한 블로그 글의 id값으로 API 호출
    - then : 응답 코드가 200 OK이고, 반환받은 content와 title이 저장된 값과 같은지 확인

## 6.6 블로그 글 삭제 API 구현하기

- 6.6.1 서비스 메서드 코드 작성하기
    - BlogService.java에 delete() 메서드 추가
        - 데이터베이스에 저장되어 있는 글의 ID를 이용해 글 삭제
- 6.6.2 컨트롤러 메서드 코드 작성하기
    - /api/articles/{id} DELETE 요청이 오면 블로그 글을 삭제하기 위한 findArticle() 메서드 작성
- 6.6.3 실행 테스트하기
    - 포스트맨에서 Delete하고 블로그 글 조회 요청 보냄 → id가 1번인 글 삭제됨
- 6.6.4 테스트 코드 작성하기
    - given : 블로그 글 저장
    - when : 저장한 블로그 글의 id값으로 API 호출
    - then : 응답 코드가 200 OK이고, 블로그 글 리스트를 전체 조회해 조회한 배열 크기가 0인지 확인

## 6.7 블로그 글 수정 API 구현하기

- 6.7.1 서비스 메서드 코드 작성하기
    - BlogService.java에 특정 아이디의 글을 수정하는 update() 메서드 추가
    - @Transactional : 메서드를 하나의 트랜젝션으로 묶는 역할 → update()는 엔티티의 필드 값이 바뀌면 중간에 에러가 발생해도 제대로 된 값 수정 보장받
- 6.7.2 컨트롤러 메서드 코드 작성하기
    - /api/articles/{id} PUT 요청이 오면 블로그 글을 수정하기 위한 updateArticle() 메서드 작성
- 6.7.3 실행 테스트하기
    - 포스트맨에서 실행
- 6.7.4 테스트 코드 작성하기
    - given : 블로그 글 저장, 블로그 글 수정에 필요한 요청 객체 생성
    - when : UPDATE API로 수정 요청 보냄 (요청 타입 : JSON, 만들어 둔 객체를 요청 본문으로 함께 보냄)
    - then : 응답 코드가 200 OK이고, 블로그 글 id로 조회한 후에 값이 수정되었는지 확인
