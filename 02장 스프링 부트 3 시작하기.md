# 02장 스프링 부트 3 시작하기

## 2.1 스프링과 스프링 부트

- 2.1.1 스프링의 등장
    - 엔터프라이즈 애플리케이션
        - 대규모의 복잡한 데이터를 관리하는 애플리케이션
        - 소프트웨어 분야가 발전하면서 점점 복잡해짐
        - 많은 사용자의 요청을 동시에 처리 → 서버 성능, 안정성, 보안 매우 중요
    - 스프링 프레임워크
        - 서버 성능, 안정성, 보안을 매우 높은 수준으로 제공
        - 엔터프라이즈 애플리케이션을 위한 개발 환경을 제공, 기능 개발에 집중할 수 있게 함
- 2.1.2 스프링을 더 쉽게 만들어주는 스프링 부트
    - 스프링 단점 : 설정이 매우 복잡함 → 단점을 보완하고자 스프링 부트 출시
    - 스프링 부트
        - 스프링 프레임워크를 더 쉽고 빠르게 이용할 수 있도록 만들어주는 도구(스프링에 속한 도구)
        - 빠르게 스프링 프로젝트 설정 가능
        - 의존성 세트라고 불리는 스타터를 사용해 간편하게 의존성 사용 및 관리
        - 개발자가 조금 더 비즈니스 로직 개발에만 집중할 수 있도록 만들어줌
    - 스프링 부트의 주요 특징
        - 톰캣, 제티, 언더토우 같은 웹 애플리케이션 서버가 내장되어 있어 따로 설치를 하지 않아도 독립적으로 실행할 수 있음
        - 빌드 구성을 단순화하는 스프링 부트 스타더 제공
        - XML 설정을 하지 않고 자바 코드로 모두 작성 가능
        - JAR을 이용해 자바 옵션만으로도 배포 가능
        - 애프리케이션의 모니터링 및 관리 도구인 스프링 액츄에이터 제공
    - 스프링 vs 스프링 부트
        - 차이점 1. 구성의 차이
            - 스프링 : 애플리케이션 개발에 필요한 환경을 수동으로 구성, 정의
            - 스프링 부트 : 스프링 코어와 스프링 MVC의 모든 기능을 자동으로 로드 (수동 구성 필요 X)
        - 차이점 2. 내장 WAS의 유무
            - WAS : 웹 애플리케이션을 실행하기 위한 장치
            - 스프링 : 애플리케이션이 일반적으로 톰캣과 같은 WAS에 배포됨
            - 스프링 부트 : WAS를 자체적으로 가짐
                - jar 파일만 만들면 벌도 WAS 설정 없이 애플리케이션 실행 가능
                - 내장 WAS : 톰캣, 제티, 언더토우 (상황에 맞게 선택)
        - 그 외 차이점
            - 스프링 : 일부 파일은 XML로 직접 생성하고 관리 / 스프링 부트 : XML 사용하지 않음
            - 스프링 : 인메모리 데이터베이스 지원 X / 스프링 부트 : 인메모리 데이터베이스 자동 설정 지원

## 2.2 스프링 콘셉트 공부하기

- 2.2.1 제어의 역전과 의존성 주입
    - 스프링의 모든 기능의 기반은 제어의 역전(IoC)과 의존성 주입(DI)에 있음
    - ⭐️ loC란?
        - Inversion of Control의 줄임말
        - 다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와 사용하는 것
        - 스프링은 스프링 컨테이너가 객체를 관리, 제공하는 역할을 함
    - ⭐️ DI란?
        - Dependency Injection의 줄임말
        - 제어의 역전을 구현하기 위해 사용하는 방법
        - 어떤 클래스가 다른 클래스에 의존
        - @Autowired : 스프링 컨테이너에 있는 빈을 주입하는 역할을 함
            - **빈 : 스프링 컨테이너에서 관리하는 객체**
        - 스프링 컨테이너에서 객체를 주입해줌
            - 클래스 A에서 B 객체를 쓰고 싶은 경우 스프링 컨테이너에서 객체를 주입받아 사용함
- 2.2.2 빈과 스프링 컨테이너
    - 스프링 컨테이너
        - 빈이 생성되고 소멸되기까지의 생명주기를 관리함
        - 개발자가 @Autowired 같은 애너테이션을 사용해 빈을 주입받을 수 있게 DI를 지원함
    - 빈
        - 스프링 컨테이너가 생성하고 관리하는 객체
        - 빈을 등록하는 방법
            - 예) MyBean 클래스에 @Component 애너테이션을 붙이면 MyBean 클래스가 빈으로 등록됨 (빈의 이름은 클래스 이름의 첫 글자를 소문자로 바꿔 관리하기 때문에 myBean이 됨)
- ⭐️ 2.2.3 관점 지향 프로그래밍(AOP)
    - Aspect Oriented Programming의 줄임말
    - 프로그래밍에 대한 관심을 핵심 관점, 부가 관점으로 나누어서 관심 기준으로 모듈화하는 것
        - 부가 관점 코드를 핵심 관점 코드에서 분리할 수 있게 해줌
    - 예) 계좌 이체, 고객 관리 프로그램
        - 로깅 로직(지금까지 벌어진 일을 기록), 데이터베이스 연결 로직이 포함됨
        - 핵심 관점 : 계좌 이체, 고객 관리 로직
        - 부가 관점 : 로깅, 데이터베이스 연결 로직 (계좌 이체와 고객 관리에 모두 필요함)
    - 장점
        - 핵심 관점 코드에만 집중할 수 있게 됨 + 프로그램 변경, 확장에 유연하게 대처 가능
- ⭐️ 2.2.4 이식 가능한 서비스 추상화
    - PSA(Portable Service Abstraction)
    - 스프링에서 제공하는 다양한 기술들을 추상화해 개발자가 쉽게 사용하는 인터페이스
    - 대표적인 PSA 예 : 클라이언트의 매핑, 클래스 또는 메서드 매핑을 위한 애너테이션
        - 스프링에서 데이터베이스로 접근하기 위한 기술을 어느 것을 사용해도 일관된 방식으로 데이터베이스에 접근하도록 인터페이스 지원
        - WAS : 코드는 그대로 두고 WAS를 톰캣이 아닌 언더토우, 네티와 같은 다른 곳에서 실행해도 기존 코드 그대로 사용 가능
- 정리 : 스프링 프레임워크는 IoC/DI를 통해 객체 간의 의존 관계를 설정하고, AOP를 통해 핵심 관점과 부가 로직을 분리해 개발하며, PSA를 통해 추상화된 다양한 서비스들을 일관된 방식으로 사용하도록 함
    - IoC : 객체의 생성과 관리를 개발자가 하는 것이 아니라 프레임워크가 대신하는 것
    - DI : 외부에서 객체를 주입받아 사용하는 것
    - AOP : 프로그래밍을 할 때 핵심 관점과 부가 관점을 나눠 개발하는 것
    - PSA : 어느 기술을 사용하던 일관된 방식으로 처리하도록 하는 것

## 2.3 스프링 부트 3 둘러보기

- 2.3.1 첫 번째 스프링 부트 3 예제 만들기
    - 사용자가 /test Get 요청을 하면 “Hello, world!” 문자열을 반환하는 코드
    
    ```java
    package org.example.springbootdeveloper;
    
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    @RestController
    public class TestController {
        @GetMapping("/test")
        public String test(){
            return "Hello, world!";
        }
    }
    ```
    
    - [http://localhost:8080/test](http://localhost:8080/test) 접속하면 화면에 문자열 제대로 출력됨
    - localhost : 아이피로는 127.0.0.1, 컴퓨터 네트워크에서 사용하는 루프백 호스트명 (현재 사용하는 컴퓨터를 의미함)
    - 8080 : 스프링 부트의 포트 번호
    - /test : @GetMapping 애너테이션으로 메서드와 매핑할 때 스프링 부트에서 설정한 경로
- 2.3.2 스프링 부트 스타터 살펴보기
    - 스프링 부트 스타터는 의존성이 모여 있는 그룹
    - 스타터 사용하면 필요한 기능을 간편하게 설정 가능
    - 명명규칙 : **spring-boot-starter-{작업유형}**
    - 자주 사용하는 스타터
        - spring-boot-starter-web : Spring MVC를 사용해서 RESTful 웹 서비스를 개발할 때 필요한 의존성 모음
        - spring-boot-starter-test : 스프링 애플리케이션을 테스트하기 위해 필요한 의존성 모음
        - spring-boot-starter-validation : 유효성 검사를 위해 필요한 의존성 모음
        - spring-boot-starter-actuator : 모니터링을 위해 애플리케이션에서 제공하는 다양한 정보를 제공하기 쉽게 하는 의존성 모음
        - spring-boot-starter-data-jpa : ORM을 사용하기 위한 인터페이스 모음인 JPA를 더 쉽게 사용하기 위한 의존성 모음
    - 프로젝트에 있는 스타터 살펴보기 (직접 따라해보는 것으로 대체)
- ⭐️ 2.3.3 자동 구성
    - 스프링 부트는 애플리케이션이 최소한의 설정만으로도 실행되게 여러 부분을 자동으로 구성함
    - 추후 개발을 하다가 내가 구성하지 않은 부분인데 스프링에서 자동으로 어떻게 구성했는지 확인할 상황이 오기 때문에 알아두어야 함
    - 스프링 부트가 서버를 시작할 때 구성 파일을 읽어와 설정함
    - META-INF에 있는 spring.factories 파일에 담겨 있음
    - 빈이 자동으로 등록되고 구성됨
- 2.3.4 스프링 부트 3와 자바 버전
    - 스프링 부트 3은 자바 17 버전 이상을 사용해야 함
    - 자바 17의 주요 변화
        - 텍스트 블록
            - “””로 감싼 텍스트를 사용해 여러 줄의 텍스트 표현 가능
        - formatted() 메서드
            - 값을 파싱하기 위한 메서드 제공
        - 레코드
            - 데이터 전달을 목적으로 하는 객체를 더 빠르고 간편하게 만들기 위한 기능
            - 상속을 할 수 없고 파라미터에 정의한 필드는 private final로 정의됨
            - getter를 자동으로 만들기 때문에 애너테이션이나 메서드로 게터 정의할 필요 없음
        - 패턴 매칭
            - nstanceof 키워드와 형변환 코드 조합 없이 바로 형변환 사용 가능
        - 자료형에 맞는 case 처리
            - switch-case문으로 자료형에 맞게 case 처리 가능
        - Servlet, JPA의 네임 스페이스가 Jakarta로 대체
            - 패키지 네임 스페이스가 javax.*에서 jakarta.*로 변경됨
        - GraalVM 기반의 스프링 네이티브 공식 지
            - 네이티브 이미지를 사용하여 가동 시간이 짧아지고 메모리를 더 적게 소모함

## 2.4 스프링 부트 3 코드 이해하기

- 2.4.1 @SpringBootApplication 이해하기
    
    ```java
    @SpringBootApplication
    public class SpringBootDeveloperApplication {
        public static void main(String[] args){
            SpringApplication.run(SpringBootDeveloperApplication.class, args);
        }
    }
    ```
    
    - 이 애너테이션을 추가하면 스프링 부트 사용에 필요한 기본 설정을 해줌
    - SpringApplication.run() : 애플리케이션 실행
        - 첫 번째 인수 : 스프링 부트 3 애플리케이션의 메인 클래스로 사용할 클래스
        - 두 번째 인수 : 커맨드 라인의 인수들을 전달함
    - @SpringBootApplication 애너테이션 구성
        - @SpringBootConfiguration
            - 스프링 부트 관련 설정을 나타내는 애너테이션
        - @ComponentScan
            - 사용자가 등록한 빈을 읽고 등록하는 애너테이션
            - @Component 애너테이션을 가진 클래스들을 찾아 빈으로 등록하는 역할을 함
            - @Component를 감싸는 애너테이션
                - @Configuration : 설정 파일 등록
                - @Repository : ORM 매핑
                - @Controller, @RestController : 라우터
                - @Service : 비즈니스 로직
        - @EnableAutoConfiguration
            - 스프링 부트에서 자동 구성을 활성화하는 애너테이션
            - 스프링 부트 서버가 실행될 때 스프링 부트 메타 파일을 읽고 정의된 설정들을 자동으로 구성하는 역할 수행
- 2.4.2 테스트 컨트롤러 살펴보기
    
    ```java
    @RestController
    public class TestController {
        @GetMapping("/test")
        public String test(){
            return "Hello, world!";
        }
    }
    ```
    
    - @RestController : 라우터 역할을 함, 클라이언트 요청에 맞는 메서드 실행
        - 라우터 : HTTP 요청과 메서드를 연결하는 장치
    - 위 예제의 경우 TestController를 라우터로 지정 → /test 라는 GET 요청이 왔을 때 test() 메서드를 실행하도록 구성
    - @RestController와 @Component가 어떻게 같은 @Component처럼 취급되는 것인가?
        - @RestController 안에 @Controller가 있음
        - **@Controller 안에 @Component가 있음**
        - 따라서 @Controller이 @ComponentScan을 통해 빈으로 등록되는 것
        - @Configuration, @Repository, @Service 모두 @Component를 가짐, 역할 구분을 위해 각각 다른 이름 사용
