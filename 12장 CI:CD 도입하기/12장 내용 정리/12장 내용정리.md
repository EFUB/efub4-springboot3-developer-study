# 12장 CI/CD 도입하기

## 12.1 사전 지식: CI/CD

### 12.1.1 CI/CD란?

- 일종의 방법을 말함
    - 빌드부터 배포까지의 과정 자동화, 잘되는지 모니터링 가능
- CI : 지속적 통합(Continuous Integration)
    - 개발자를 위해 빌드와 테스트를 자동화하는 과정 [빌드 → 테스트 → 통합]
    - 변경 사항을 자동으로 테스트 → 애플리케이션에 문제가 없다는 것을 보장함
    - 코드를 정기적으로 빌드 및 테스트 → 여러 명이 동시에 작업하는 경우 충돌 방지 및 모니터링
    - 코드 변경 사항 코드 저장소 업로드 → CI 시작 → CI 도중 문제 생기면 실패
- CD : 지속적 제공(Continuous delivery)
    - CI 작업 후 실행하는 작업
    - 지속적 제공에서의 CD 의미
        - CI 통과 후 깃허브와 같은 코드 저장소에 자동으로 업로드하는 과정
        - 최소의 노력으로 코드 배포를 쉽게 함
        - CI + 리포지터리에 자동으로 병합
    - 지속적 배포에서의 CD 의미
        - 지속적 제공을 통해 성공적으로 병합한 코드 내역을 AWS와 같은 배포 환경으로 보내는 것 = 릴리스
        - 지속적 제공의 다음 단계까지 자동화함
        - CI + 리포지터리에 자동으로 병합 + 프로덕션 환경에 자동으로 배포

### 12.1.2 깃과 깃허브

- 깃
    - 코드를 저장하고 관리할 수 있는 시스템
    - 병렬 개발 가능하게 함
- 깃허브
    - 깃과 연동해 작업한 코드를 저장할 수 있는 서비스
- 깃허브와 깃 연동하기
    - 깃 초기 설정
    
    ```bash
    $ git config --global user.name "[깃허브 아이디]"
    $ git config --global user.email "[깃허브 이메일 주소]"
    ```
    
    - SSH 키 생성
    
    ```bash
    $ ssh-keygen -t rsa -C "[깃허브 이메일 주소]"
    ```
    
    - /.ssh/id_rsa의 pub 파일 내용 전체 복사
    - 깃허브 [Settings] → [SSH and GPG keys] → [New SSH key] 눌러 새로운 키 등록

## 12.2 깃허브 액션 사용하기

- 깃허브 액션
    - 깃허브에서 제공하는 서비스
    - 리포지토리에 특정 이벤트가 발생하면 특정 작업을 하거나, 주기적으로 특정 작업을 반복할 수 있게 함
    - 예) 코드 작성 후 깃허브에 업데이트 → 코드에 문제 없는지 자동으로 빌드, 테스트 후 배포

### 12.2.1 깃허브 리포지터리 생성하고 코드 푸시하기

- push : 깃허브에 코드를 업로드하는 행위
1. 깃허브 홈페이지 : [New repository] → 리포지터리 생성
2. 생성된 리포지터리의 SSH 주소 복사
3. 인텔리제이 작업한 프로젝트 열기 → 인텔리제이 터미널 창 열고 git init 입력
    1. git init : 특정 폴더를 깃 저장소로 만들 때 사용하는 명령어
    2. .git 폴더가 숨김 폴더로 생성됨 → 코드의 변경 내역 관리를 위한 정보가 저장됨
4. 깃허브 리포지토리와 로컬의 깃 저장소 연결 → remote 사용
    1. origin에 git@github.com~ 리포지토리 추가
    
    ```bash
    $ git remote add origin git@github.com:${사용자계정명}/springboot-developer.git
    ```
    
5. add, commit
    1. add . 명령어 : 현재 프로젝트 폴더의 모든 파일을 대상으로 변경 사항 추적, 그 파일들을 스테이지에 올림
        1. 스테이지 : 리포지토리에 올리기 전 파일들의 변경사항을 모아놓는 곳
    2. commit : 로컬 저장소에 올리기 위한 것으로 커밋을 해야만 로컬 저장소에 변경 이력, 변경한 파일들이 업데이트됨
    
    ```bash
    $ git add .
    $ git commit -m "project init"
    ```
    
6. 브랜치명을 main으로 바꾼 후 push 명령어 입력하여 깃허브 리포지토리에 코드 업데이트
    
    ```bash
    $ git branch -M main
    $ git push origin main
    ```
    
7. 깃허브 접속하여 리포지토리 확인

### 12.2.2 깃허브 액션 스크립트 작성하기, CI

1. 프로젝트 최상단에 .github 디렉터리 생성 → 그 안에 workflows 디렉터리 생성 후 ci.yml 파일 생성
2. 추가된 파일 커밋, 푸시 진행 후 깃허브 리포지터리의 [Action] 들어가 CI 실행 확인
    
    ![스크린샷 2024-06-29 오후 4.52.18.png](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%E1%84%87%E1%85%AE%E1%84%90%E1%85%B33%203837afd158ed4ea385a25b5a8a2cb3f0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-06-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.52.18.png)
    

### 12.2.3 깃허브 액션 스크립트 작성하기, CD

1. 현재 프로젝트 빌드 → 총 2개의 jar 파일 생성됨
    1. 하나는 일반 jar
    2. 다른 하나는 plain이라는 접미사가 붙은 jar 파일
        1. 플레인 아카이브라고 하며, 실행에 필요한 의존성 포함 X, 소스 코드의 클래스 파일과 리소스 파일만 포함
    3. 플레인 아카이브만으로는 서비스 실행 불가 → 빌드 시 일반 jar 파일만 생성하도록 그레이들 파일 변경
2. ci.yml을 cicd.yml로 변경 후 코드 추가
3. AWS 접속 → IAM 서비스 검색 → [사용자] → [사용자 추가]
4. 권한 설정 [직접 정책 연결] → AdministratorAccess-AWSElasticBeanstalk 선택
    1. 빈스토크를 사용하기 위해 필요한 모든 관리 권한을 사용자에게 제공하는 권한
5. 사용자 생성 마친 후 사용자 눌러 액세스 키 생성
    1. [액세스 키 만들기] → [서드 파티 서비스] → 설명 태그 값 지정 후 액세스 키 생성
6. 생성된 액세스 키는 딱 한 번만 확인할 수 있기 때문에 값을 미리 복사해두거나 .csv 파일 다운하기
7. 깃허브 리포지토리 접속 → [Settings → Secrets and variables → Actions] → [New repository secrets] 버튼 눌러 새로운 비밀 키 등록
8. 깃허브에 커밋, 푸시하기 전에 민감한 값 삭제
9. 커밋, 푸시 수행 후 깃허브 액션 성공 확인
    
    ![스크린샷 2024-06-30 오전 2.26.12.png](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%E1%84%87%E1%85%AE%E1%84%90%E1%85%B33%203837afd158ed4ea385a25b5a8a2cb3f0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-06-30_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.26.12.png)